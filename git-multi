#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright 2013 Tomo Krajina
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys as mod_sys
import os as mod_os
import os.path as mod_path
import datetime as mod_datetime

try:
    import argparse as mod_argparse
except ImportError:
    print 'ERROR: Missing argparse module: Requires Python >= 2.7'
    mod_sys.exit(1)

import gitutils as mod_gitutils

Description = """
The git-multi script enhances git with a new command: 'multi'. All
arguments not known to git-multi are passed through to the git command
run for each repo found in the directory.

This lets you run a single git command on multiple git repos with a
single command line.
"""

Epilog = """
Some git-multi arguments can mask git command arguments. To work around
this, add a '--' argument after the last git-multi argument and all
arguments after the '--' will be ignored by git-multi and passed
directly to git. For example, to run 'git multi branch -a' without
triggering 'git multi --archive':

    $ git multi branch -- -a

The -p options will override excluded projects (either in
.multigit_ignore or given with -e) allowing git-multi to operate on
them.
"""

# Prefix for git command output:
PREFIX = '\t'

current_path = mod_os.getcwd()

# Check if to group results by output:
# Set by:
# 	git config --global 'multi.groupbyoutput' 1
# Unset by:
# 	git config --global --unset 'multi.groupbyoutput'
def process_global_config():
    multi_cfg = {}
    config_properties = mod_gitutils.get_config_properties()
    value = config_properties.get('multi.groupbyoutput', 'false')
    multi_cfg['group_by_output'] = True if value.lower() in ('true', '1') else False
    return multi_cfg

def parse_cmd_line ():
    # Values from git config files as defaults where appropriate.
    multi_global_config = process_global_config()

    # Handle multi args which conflict with git args.
    argv = mod_sys.argv[1:]
    if '--' in argv:
        idx = argv.index('--')
        multi_args = argv[:idx]
        g_args = argv[idx+1:]
    else:
        multi_args = argv
        g_args = []

    parser = mod_argparse.ArgumentParser(description=Description, epilog=Epilog,
                                         formatter_class=mod_argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-a', '--archive',
                        action='store_true',
                        help='Archive projects to a tarball.')
    parser.add_argument('--branch',
                        action='store_true',
                        help='Output only the current branch for all projects.')
    parser.add_argument('--branch-verbose',
                        action='store_true',
                        help='Verbose branch information (same as --branch, but more verbose)')
    parser.add_argument('-B', '--branch-name',
                        action='store',
                        help='Show projects not on specified branch')
    parser.add_argument('-c', '--changed',
                        action='store_true',
                        dest='only_if_changed',
                        help='Execute only if project not changed.')
    parser.add_argument('--debug',
                        action='store_true',
                        help='Output git-multi debug information.')
    parser.add_argument('-e', '--exclude',
                        action='append',
                        metavar='PROJECT',
                        help='Add project to list of projects to exclude.')
    parser.add_argument('-g', '--group-by-output',
                        action='store_true',
                        dest='group_by_output',
                        default=multi_global_config['group_by_output'],
                        help='Projects with same git command output will be groupped together.')
    parser.add_argument('-p', '--project',
                        action='append',
                        metavar='PROJECT',
                        dest='project_list',
                        help=("Add arg to list of projects to work on. "
                              "Can be given multiple times. Each PROJECT value can be "
                              "a ':' separated list of projects."))
    parser.add_argument('-q', '--quiet',
                        action='store_true',
                        dest='be_quiet',
                        help='If project unchanged, do not output anything.')

    opts,git_args = parser.parse_known_args(args=multi_args)
    git_args.extend(g_args)

    opts.show_progress = True

    # Force group by output if '--branch-verbose' is used.
    if opts.branch_verbose:
        opts.group_by_output = True

    # Allow each instance of -p to specify multiple projects separated with ':'.
    if opts.project_list is None:
        opts.project_list = []

    if opts.project_list:
        proj_list = []
        for proj in opts.project_list:
            proj_list.extend(proj.split(':'))
        opts.project_list = proj_list

    # Add projects from .multigit_ignore to exclude list.
    if opts.exclude is None:
        opts.exclude = []
    else:
        excl = []
        for proj in opts.exclude:
            excl.extend([p for p in proj.split(':') if p not in opts.project_list])
        opts.exclude = excl

    if mod_path.exists('.multigit_ignore'):
        for line in open('.multigit_ignore'):
            project = line.strip()
            if project not in opts.project_list:
                opts.exclude.append(project)

    if opts.exclude:
        print 'Ignoring:'
        for proj in opts.exclude:
            print '%s%s' % (PREFIX, proj)

    return opts,git_args


def process_project(current_path, file_name, options):
    dir_path = '%s/%s' % (current_path, file_name)
    mod_os.chdir(dir_path)

    if not mod_gitutils.is_changed():
        if options.be_quiet:
            return

    output = ''

    if options.group_by_output or options.branch_name:
        do_output = False
    else:
        do_output = True

    if not options.group_by_output:
        print '%s:' % file_name

    execute = True
    if options.only_if_changed:
        execute = mod_gitutils.is_changed()
        if not execute:
            output = PREFIX + 'Not changed'
            if do_output:
                print output

    if execute:
        executed, result = mod_gitutils.execute_command(git_command, output=do_output, prefix=PREFIX, grep=grep)
        result = result.rstrip()

        if not executed:
            output = '\tError executing:%s' % git_command
        elif options.branch_name:
            # Only output repos not on branch
            branch_name_differs = (options.branch_name != result.strip())
            if branch_name_differs:
                print '\tCurrent branch: %s' % result
        elif result:
            output = result
        else:
            output = '\tOK'

    if options.group_by_output:
        if output in outputs:
            outputs[output].append(file_name)
        else:
            outputs[output] = [file_name]

options,git_args = parse_cmd_line()

if options.debug:
    print 'OPTS:', options
    print 'GIT_ARGS:', git_args

# Execute backup?
if options.archive:
    now = mod_datetime.datetime.now()
    now = now.strftime('%Y-%m-%d-%H-%M')
    tar_name = 'git-repositories-%s.tar.xz' % (now)

    repos = mod_gitutils.get_project_list(options.exclude)

    dot_gitignores = []
    for repo in repos:
        for root, dirs, files in mod_os.walk(repo):
            if '.git' in dirs:
                dirs.remove('.git')
            if '.gitignore' in files:
                dot_gitignores.append (mod_os.path.join(root, '.gitignore'))

    tar_command = ['tar', 'cvJf', tar_name]
    tar_command.extend(['%s/.git' % repo for repo in repos])
    if dot_gitignores:
        tar_command.extend(dot_gitignores)

    executed, output = mod_gitutils.execute_command(tar_command, output=True)

    if executed:
        print 'Saved git repositories to %s' % tar_name

    mod_sys.exit(0)

grep = None

# If no specific command is entered (i.e. only 'git multi'):
git_command = ['status', '-s']

if git_args:
    git_command = git_args

if options.branch_verbose:
    git_command = ['branch', '-v']
    grep = '* '
elif options.branch or options.branch_name:
    git_command = ['rev-parse', '--abbrev-ref', 'HEAD']


if git_command[0] == 'gitk':
    git_command = git_command
else:
    git_command.insert(0, 'git')

print '--------------------------------------------------------------------------------'
if grep:
    print 'Executing: %s | grep %s' % (' '.join(git_command), grep)
else:
    print 'Executing %s' % ' '.join(git_command)
print '--------------------------------------------------------------------------------'

# Used when group_by_output == True, keys are output, values are a list of projects
outputs = {}

if options.show_progress and options.group_by_output:
    print 'Progress:',
    mod_sys.stdout.flush()

# Execute command on all subdirectories:
for file_name in mod_gitutils.get_project_list(options.exclude):
    if not options.project_list or file_name in options.project_list:
        mod_os.chdir(current_path)

        if mod_path.isdir(file_name):
            if mod_path.exists('%s/.git' % file_name):
                process_project(current_path, file_name, options)

                if options.show_progress and options.group_by_output:
                    print '*',
                    mod_sys.stdout.flush()
if options.show_progress and options.group_by_output:
    print
    print '--------------------------------------------------------------------------------'

# If group_by_output, then output them now:
if options.group_by_output:
    result_outputs = []
    output_keys = outputs.keys()
    output_keys.sort()
    for output in output_keys:
        projects = outputs[output]
        projects.sort()

        result_outputs.append([', '.join(projects) + ':', output])
        print

    result_outputs.sort()
    for key, value in result_outputs:
        print key
        print value
        print
